# 목차
- 새로운 할인 정책 개발
- 새로운 할인 정책 적용과 문제점
- 관심사의 분리
- AppConfig 리팩터링
- 새로운 구조와 할인 정책 적용
- 전체 흐름 정리
- 좋은 객체 지향 설계의 5가지 원칙의 적용
- IoC, DI, 그리고 컨테이너
- 스프링으로 전환하기

>핵심은 객체지향 원리 적용하기

<br>
<br>
<br>
<br>

# 새로운 할인 정책 개발
## 정률 할인 정책 개발
~~~java
package hello.core.discount;

import hello.core.member.Grade;
import hello.core.member.Member;

public class RateDiscountPolicy implements DiscountPolicy{

    int discountPercent = 10; //10프로 할인

    @Override
    public int discount(Member member, int price) { //컨트롤 쉬프트 티 =테스트 클래스 생성 단축키

        if (member.getGrade() == Grade.VIP){
            return price*discountPercent/100;  //vip이면 10할인
        }
            else{
         return  0;
        }
    }
}

~~~
<br>
<br>

# 새로운 할인 정책 적용과 문제점

## 새로운 정책 할인 적용 및 테스트
~~~java
package hello.core.order;

import hello.core.discount.DiscountPolicy;
import hello.core.discount.FixDiscountPolicy;
import hello.core.discount.RateDiscountPolicy;
import hello.core.member.Member;
import hello.core.member.MemberMemoryRepository;
import hello.core.member.MemberRepository;

public class OrderServiceImpl implements OrderService{

    MemberRepository memberRepository = new MemberMemoryRepository();

    //DiscountPolicy discountPolicy = new RateDiscountPolicy(); 변경 전 
    DiscountPolicy discountPolicy = new RateDiscountPolicy();  //변경 후

    @Override
    public Order orderCreate(Long memberId, String itemName, int itemPrice) {
        Member member = memberRepository.findById(memberId);
        int discountPrice = discountPolicy.discount(member, itemPrice);

        return new Order(memberId, itemName, itemPrice, discountPrice);


    }

}
~~~
## 테스트
~~~java
package hello.core.discount;

import hello.core.member.Grade;
import hello.core.member.Member;

import org.assertj.core.api.Assertions;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;


class RateDiscountPolicyTest {

    RateDiscountPolicy rateDiscountPolicy = new RateDiscountPolicy();

    @Test
    @DisplayName("vip 맞을시") //테스트함수명대신 나오는 스트링
    public void 퍼센트할인테스트() {

        Member member = new Member(1L, "승빈", Grade.VIP);  //새로운 멤버 생성

        int discount = rateDiscountPolicy.discount(member, 10000); 

        Assertions.assertThat(discount).isEqualTo(1000); //할인 가격이 1000이 맞는지 확인 
    }

    //성공 테스트도 중요하지만 실패 테스트도 꼭 만들어 봐야한다.

    @Test
    @DisplayName("vip 아닐시")
    public void 퍼센트할인테스트2() {

        Member member = new Member(1L, "승빈", Grade.BASIC);

        int discount = rateDiscountPolicy.discount(member, 10000);

        Assertions.assertThat(discount).isEqualTo(0);
    }
}
~~~
![새로운정책 테스트](https://user-images.githubusercontent.com/89888075/163761552-81078a5e-cc92-4583-b139-90157a8379a1.PNG)


## 문제점
~~~java
    //DiscountPolicy discountPolicy = new RateDiscountPolicy(); 변경 전 
    DiscountPolicy discountPolicy = new RateDiscountPolicy();  //변경 후
~~~
- 새로운 정채을 변경할때 새로운 정책의 구현채만 바꾸어주면 되지만 여기에는 아래와 같은 문제점이 있다
 - OCP,DIP 객체지향 설계 원칙 위반 
   - DIP : OrderServiceImpl클래스는 DiscountPolicy 인터페이스에 의존하면서 DIP를 지킨거같지만 사실은 인터페이스 뿐만아니라 구현 클래스에도 의존하고 있다.
   - OCP: 지금 코드는 기능을 확장해서 변경하려면, 클라이언트 코드에 영향을 준다.

## 해결 방안
이 문제를 해결하기위해선 누군가가 클라이언트인 OrderService에 DiscountPolicy이 구현 객체를 대신 생성하고 주입해주어야 한다.
(AppConfig라는 애플리케이션의 전체 동작 방식을 구성(config)하기 위해, 구현 객체를 생성하고 , 연결하는 책임을 가지는 별도의 설정 클래스를 만들자!)


<br>
<br>

# 관심사의 분리

<br>
<br>

# AppConfig 리팩터링

<br>
<br>

# 새로운 구조와 할인 정책 적용

<br>
<br>

# 전체 흐름 정리

<br>
<br>

# 좋은 객체 지향 설계의 5가지 원칙의 적용

<br>
<br>

# IoC, DI, 그리고 컨테이너

<br>
<br>

# 스프링으로 전환하기